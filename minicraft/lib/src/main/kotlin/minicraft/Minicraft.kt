/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package minicraft

import minicraft.gl.FragmentShader
import minicraft.gl.Program
import minicraft.gl.VertexShader
import minicraft.render.Cube
import org.joml.Matrix4f
import org.joml.Vector3f
import org.lwjgl.BufferUtils
import org.lwjgl.glfw.GLFW.*
import org.lwjgl.opengl.GL
import org.lwjgl.opengl.GL11
import org.lwjgl.opengl.GL20.glUniformMatrix4fv
import org.lwjgl.opengl.GL30.*


class Minicraft {
    private lateinit var shaderProgram: Program
    private lateinit var cube: Cube

    fun init() {
        if (!glfwInit()) {
            throw IllegalStateException("Unable to initialize GLFW")
        }
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3)
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3)
        glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE)
        glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GLFW_TRUE)

        val window = glfwCreateWindow(640, 480, "Hello World", 0, 0)
        if (window == 0L) {
            glfwTerminate()
            throw IllegalStateException("Failed to create window")
        }
        glfwMakeContextCurrent(window)

        GL.createCapabilities()
        glViewport(0, 0, 640, 480)
        glfwSetFramebufferSizeCallback(window) { _, width, height ->
            glViewport(0, 0, width, height)
        }
        glEnable(GL_DEPTH_TEST)

        shaderProgram = Program(
            listOf(
                VertexShader(readSourceAsString("shaders/vertex.vert")),
                FragmentShader(readSourceAsString("shaders/fragment.frag"))
            )
        )
        shaderProgram.link(destroyShaders = true)
        cube = Cube("textures/grass.png")
        cube.setup()



        while (!glfwWindowShouldClose(window)) {
            glClearColor(0.8f, 0.8f, 0.8f, 1.0f)
            glClear(GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT)

            render()

            glfwPollEvents()
            glfwSwapBuffers(window)
        }

        cube.destroy()
        shaderProgram.destroy()
        glfwTerminate()
    }

    private fun render() {
        shaderProgram.use()

        val modelBuffer = BufferUtils.createFloatBuffer(16)
        val cameraBuffer = BufferUtils.createFloatBuffer(16)
        val projBuffer = BufferUtils.createFloatBuffer(16)

//        cube.modelMatrix().get(modelBuffer)
        Matrix4f().rotate(Math.toRadians(45.0).toFloat(), Vector3f(0.6f, 0.8f, 0.0f)).get(modelBuffer)
        Matrix4f().translate(0f, 0f, -3f).get(cameraBuffer)

        val viewPorts = intArrayOf(0, 0, 0, 0)
        GL11.glGetIntegerv(GL_VIEWPORT, viewPorts)
        Matrix4f().perspective(Math.toRadians(45.0).toFloat(), viewPorts[2].toFloat() / viewPorts[3], 0.1f, 100f)
            .get(projBuffer)

        glUniformMatrix4fv(shaderProgram["model"], false, modelBuffer)
        glUniformMatrix4fv(shaderProgram["camera"], false, cameraBuffer)
        glUniformMatrix4fv(shaderProgram["projection"], false, projBuffer)

        cube.render()
    }
}

fun main() {
    val minicraft = Minicraft()
    minicraft.init()
}